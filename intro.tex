
\chapter{Introduction}

\section{What is a Data Structures Course}
Data Structures is all about defining the different ways we can organize data.  This is not databases, which is concerned with defining the various attributes of a bunch of data;  this is much more granular.  We want to know how to store and retrieve a single item of data.


\section{Why This Book?}

This textbook is free.

It is both Java and Python, which is a bit insane.  You have two valid choices: 
\begin{itemize}
	\item Understand that the concepts we are learning are way more important than the language and treat the other language as psuedocode (which isn't hard for Python)
	\item Be comfortable in multiple languages and embrace being a polyglot.  Impress your friends, wow your rivals!
	
\end{itemize}



\subsection{Where Does This Book Fit Into a Computer Science Curriculum }

Education in Computer Science is based around three core topics: translating the steps of solving a problem into a language a computer can understand, organizing data for solving problems, and techniques that can be used to solve problems. % reword
These courses typically covered in a university's introductory course, data structures course, and algorithms course respectively, although different universities decide exactly what content fits in which course.
Of course, there is are lot more concepts in computer science, from operating systems and low level programming,  to networks and how computers talk to each other. However, all these concepts rely on the knowledge gained in the core courses of programming, data structures, and algorithms.



This textbook is all about Data Structures, the middle section between learning how to program and the more advanced problem solving concepts we learn in Computer Science. 
Here, we focus on mastering the different ways to organize data, recognize the internal and performative differences between each structure, and learn to recognize the best (if there is one) for a given situation.


\subsection{What Are My Base Assumptions about the Reader?}

This textbook assumes that the student has taken a programming course that has covered the basics.
Namely: data types such as ints, doubles, booleans, and strings; if statements, for and while loops; and object orient programming.
This book is also suitable for the self taught programmer who has not learned much theoretical programming

\section{To The Instructor}


\subsection{Professor Rosen's Extremely Opinionated Advice on How to Lecture}
You'll note that this textbook lacks some of the features found in commercially available textbooks.  The biggest of these is slides.  
For the most part, slides are too static to help students understand how to code. 

I'll go a step further to be blunt: from intro to programming all the way thru data structures, slides are absolute trash;  use them if and only if you have no time to prepare.  In fact, even if you have no time to prepare, I would caution against using it.

I have been teaching Data Structures since Fall 2011.  In order of preference, this is how I would tackle \textit{this} class, which I fully recognize may not work for you or your teaching style.

\begin{description}
	\item[Lecture with slides.]  Do this if slides are available (they are not for this book) and it is your first time teaching this class.  
	\item[Lecture via live coding.] Basically, your lecture unit for a data structure should look like this\footnote{Conviently, the textbook is written for you to model this}:
	\begin{itemize}
		\item Introduce the ADT that you will be modeling.  So for a [array]list, describe what it is, why we want it over an array, and the operations.
		\item Code a functional, pedagogical implementation live in class.
		\begin{itemize}
			\item Functional means a student could ostensibly use it in an assignment.  This means most of the work will focus on \texttt{add} and  \texttt{remove} or their equivalents.
			\item Pedagogical means that you should keep straightforward  and not try to reproduce the entire built-in class.  If you're working in Java, your implemented \texttt{MyArrayList} shouldn't try to implement the \texttt{List} interface.  You should only focus on the primary ways a programmer interacts with the class in question. It also means you should emphasize that the built-in, real-world classes will have a number of optimizations that speed things up , but what you're covering is a close enough approximation.
		\end{itemize}
		\item This might be a bit unnerving to have to reproduce a class in front of the class, but watching someone program these things from scratch works better than just reading snippets of text.
		\item Mistakes will be made, but students need to see mistakes are normal.  
	\end{itemize}
	\item Do the above, but flip the lecture.  You can see my example of this
	\href{https://www.youtube.com/watch?v=FgnmWooD5Sg&list=PLNDWoTOY5hTYm38ST1lWvLy7uF4SgdtBx}{here}:
\end{description}

\subsection{Exercises}


Does the lack of varied exercises make cheating on assignments easier as semesters go on?  Yes, but that bridge was burned long ago.  
The cheating student can plagiarize from various websites or anonymously hire another to do their work for them.
However, the student who cheats isn't exactly clever and certainly hasn't been exposed to much game theory.  
They will often cheat from the same source.  

In addition, during the writing of this text, technologies such as GPTChat were released.  This hasn't so much burned the bridge as dropped napalm on the entire surrounding forest.  Newer technologies will then salt that earth. I recommend an open and honest dialogue with your students and at least 50\% of their grade being the result of evaluations and assessments you do in class.  This can range from proctored exams to flipping the classroom and giving students the chance to work  on homework in class, where they are much more likely to turn to you or their peers for help.

My personal solution for assignments is to use require students to demo their homework to me or a TA to receive a grade.  As part of this demo, they must answer questions about their solutions.  Now, as you well know, a student being unable to answer question about their work or make on the fly adjustments \textbf{isn't necessarily} an indicator that a student has cheated.  Personally, I find half of my students seem to lose approximate 50 IQ points upon being directly questioned.  It is daunting to be the sole subject of attention to the person who is making the determination as to whether you pass or fail.  But I digress.  To summarize, being unable to answer questions about their code might be an indication of cheating, it might be an indication of nerves.  In most cases, you can figure out if it's the latter case, in which case, just send them away until they can explain their code.  Don't penalize them, but remind them that programming interviews require this kind of presentation of skills. 

As far as student who use AI, AI generated code has a number of tells and those tells will change over time.  However, the usual marker is using either too well documented code and data structures or syntax well above what you would expect from a student.  Now, if the student is using Vim or Emacs or rocking Linux, they probably  can explain exactly what they are doing.  In fact, save yourself the trouble and just assign them a minimum of a B.  However, most of the time a student won't be able to explain the thought process behind the solution or the way some syntax works.  If pressed they will explain a vague ``friend'' helped them with the code.  You can press further if you want and handle it however.  Personally, it depends on where we are in the semester.  In the first few weeks, I emphasize that they will be completely wrecked by the exams if they rely on this ``friend'' and they need to do the work themselves and tell them to come back when that is the case.  At the end of the semester, I am much less inclined to have mercy.


\subsection{The Order}


\subsection{Assignments}
I will drop the sporadic assignment here or there, drawing from the same places you should draw from:
\begin{itemize}
	\item Nifty Assignments
	\item  Problem Solving with Algorithms and Data Structures using Java (Miller)
\end{itemize}

\subsection{How to Use}

%TODO create tag for teacher edition
\section{To The Student}



Why are we learning this?  As Brad Miller and David Ranum put in their aforementioned book (which is creative commons and you should totally check out):

\begin{quotation}
	
	To manage the complexity of problems and the problem-solving process, computer scientists use abstractions to allow them to focus on the “big picture” without getting lost in the details. By creating models of the problem domain, we are able to utilize a better and more efficient problem-solving process. These models allow us to describe the data that our algorithms will manipulate in a much more consistent way with respect to the problem itself.
	
	Earlier, we referred to procedural abstraction as a process that hides the details of a particular function to allow the user or client to view it at a very high level. We now turn our attention to a similar idea, that of data abstraction. An abstract data type, sometimes abbreviated ADT, is a logical description of how we view the data and the operations that are allowed without regard to how they will be implemented. This means that we are concerned only with what the data is representing and not with how it will eventually be constructed. By providing this level of abstraction, we are creating an encapsulation around the data. The idea is that by encapsulating the details of the implementation, we are hiding them from the user’s view. This is called information hiding.
	
	Figure 2 shows a picture of what an abstract data type is and how it operates. The user interacts with the interface, using the operations that have been specified by the abstract data type. The abstract data type is the shell that the user interacts with. The implementation is hidden one level deeper. The user is not concerned with the details of the implementation.

	
	Figure 2: Abstract Data Type
	
	The implementation of an abstract data type, often referred to as a data structure, will require that we provide a physical view of the data using some collection of programming constructs and primitive data types. As we discussed earlier, the separation of these two perspectives will allow us to define the complex data models for our problems without giving any indication as to the details of how the model will actually be built. This provides an implementation-independent view of the data. Since there will usually be many different ways to implement an abstract data type, this implementation independence allows the programmer to switch the details of the implementation without changing the way the user of the data interacts with it. The user can remain focused on the problem-solving process.

\end{quotation}

\subsection{How to use}

\section{License}
This work is funded by Temple University's \href{http://tupress.temple.edu/open-access/north-broad-press}{North Broad Press} and is under \href{https://creativecommons.org/licenses/by-nc/3.0/}{Creative Commons - Attribution Non Commericial License}

\section{On Styles}
On styles:  Java convention is to use camel case for variable types (\texttt{myVariableName}), while python convention is to use underscores (\texttt{my\_variable\_name}).  I will be using the Java style camel-casing for variables throughout the book for consistency and because it is my preference.
%\section{Science and Art}
