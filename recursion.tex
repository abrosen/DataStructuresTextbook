\chapter{Recursion}

\section{Introduction}

\subsection{Why?}

Much in the same way we use Object Oriented Programming as a tool to organize our thoughts about how to design large programs, programmers can use recursion to craft elegant and efficient solutions. Once you get a hang of recursion, it's a really easy way create solutions.  I often refer to it as a way to be lazy at programming, with my recursive problem solving typically going like this:

\begin{itemize}
	\item I am at some amorphous spot in the puzzle or problem I am solving. 
	\item This problem is too big to solve in one go.
	\item Let's just write code that solves only this specific part of the problem.
	\item Now that I have the solution to this portion, since I'm lazy, I'll just call a magic method that solves the rest of the problem starting at the point immediately  after what  I just solves.
	\item It turns out the magic method is what I just wrote.
\end{itemize}


Confused?  That's fine.  It often takes a few attempts to get a handle on recursion.  It should start to make sense with some examples.
\section{Recursive Mathematics}


\subsection{Fibonacci}
As it turns out, while this technically works...it's pretty terrible.  In short, using recursion, I managed to accidentally\footnote{All right, I did this totally on purpose.} write an $ O(2^n) $, or exponential time,  algorithm.  This is very bad.  This means increasing $ n $ by one \emph{doubles} the runtime of out algorithm!

This is because to solving the current $n$ requires solving $fib(n-1)$ and n-2.  Furthermore, each recursive call is independent



Don't let this terrible runtime scare you away from recursion!  Recursion can make things quite efficient; this is merely an exception and presented here because fibonacci is such a classic example we would be remiss to not incluse it.



\subsection{Summation of an Array}
%https://runestone.academy/ns/books/published/javads/recursion_calculating-the-sum-of-a-list-of-numbers.html
ADD REFERENCE HERE


We will begin our investigation with a problem that you already know how to solve without using recursion. Suppose that you want to calculate the sum of an array of numbers such as:$[1, 3, 5, 7, 9]$ An iterative method that computes the sum is shown in Listing 4.3.1. The method uses an accumulator variable (theSum) to compute a running total of all the numbers in the array by starting with and adding each number in the array.

\section{Printing Recursively}
Some of the upcoming examples  of the things we are about to see should not be actually  used and serve only as examples, like our \texttt{printThis} function.



\subsection{Recursive Linear Search}




\begin{minted}{Python3}
def search(theList, target):
	return search(theList, target, 0)


def search(theList, target, index):
	if index >= len(theList):
		return False 
	if theList[item] == target:
		return True
	return search(theList, target, index + 1)
	
\end{minted}


\subsection{Binary Search}
%Binary search is our reason for including Recursion at this location in the textbook. 






\subsubsection{Runtime Analysis}
Each step of binary search eliminates either exactly or almost exactly half of the search space or sucessfully terminates the search.

This halving at each step is represented by $log_2(n)$, where $n$ is the number of items.  Thus, with an array of 256 items, this algorithm would take approximately 8 steps. Doubling the size of the array to 512 items increases the amount of work only by a single step.   Compare that to our linear search, which starts at the beginning at goes thru the array one item at a time.  That takes $O(n)$ time.  In this case, doubling the number of items means doubling the amount of time the algorithm takes.





\subsubsection{How to not be scared of logarithms }
You may have learned that logarithms are the inverse operation to exponentiation.
This is an utterly useless definition when programming.


A more way of thinking about logarithms is "how many times can I recursively split something?"
For example, $\log_b x$ asks "how many times can I recursively split my $x$ items into $b$ seperate piles?"

A more concrete example: $\log_2 16 = 4$, not because $2^4 = 16$, but because a pile of 16 items can be split in half into two piles of 8, each pile of 8 can be split in half into two piles of 4, the 4's can be split into 2's, the 2's into 1's --- four splits total:

<picture>


In algorithm analysis, $log n$ in the time complexity is used to indicate that the search space gets split in half.
In the Binary Search algorithm above, we split the our search space in half each step of the way.  We start out looking at the middle item and then decide to look at all the items below or all the items above.  This reduces the number of items to search among from $n$ to $\frac{n}{2}$.  From there we perform the same choices and reduce that $\frac{n}{2}$ to $\frac{n}{4}$, then from  $\frac{n}{4}$ to  $\frac{n}{8}$ and so on.

\subsubsection{Back to it.}

\section{Recursive Backtracking}
Recursion really comes in handy when we are trying to solve complex puzzles.
One of the most famous examples of this is using

\subsection*{The Recursive Backtracking Algorithm}

\begin{minted}{C}
boolean solve(board,  pos){
	
	if( pos is such that there is nothing left to solve){
		return true;
	}
	
	for each possible choice {
		if(valid(choice)){
			mark board at pos with choice;
			if(solve(board, pos + 1) == true){
				return true;
			}
			unmark board at pos if needed, as choice was invalid
		}
	}
	clear any choices entered at pos on board, if needed;
	
	return false; // backtrack
}
	
	
\end{minted}


\subsection{Mazes Again}



\subsection{The Eight Queens Puzzle}

\chessboard[setwhite={Qa1,Qb7,Qc4,Qd6,Qe8,Qf2,Qg5,Qh3},showmover=false]

\subsubsection{Brute Force Solution}
A brute force algorithm means we will be checking every single possible state to find a solution.
In this case, a brute force solution for the Eight Queens Puzzle would every possible placement of eight queens on a chessboard, such as  these two:

<Chess notation here>

There are a total of $\binom{64}{8} = 4426165368$
possible ways to place 8 queens on a chessboard with 64 spaces.

\subsubsection{Recursive Solution Outline}
\begin{minted}{Java}
public static boolean solve(int[][] board, int col){
	
	if( col == 8){
		return true;
	}
	
	for(int row = 0; row < 8;row++){
		if(valid(choice)){
			mark board at pos with choice;
			if(solve(board, pos + 1) == true){
				return true;
			}
			unmark board at pos if needed, as choice was invalid
		}
	}
	clear any choices entered at pos on board, if needed;
	
	return false; // backtrack
}

\end{minted}

\subsubsection{A Place Holder For Validity}

\subsubsection{Performing the Recursion}

\subsubsection{Checking just One condition}


\subsubsection{Checking all the Conditions}




\subsection{Additional Problems left to the Reader}

\subsubsection{Knight's Tour}

\subsubsection{Sudoku}




\section{Recursive Combinations}



\section{Recursion and Puzzles}



\section{Recursion and Art}

\section{Recursion and Nature}
