\chapter{Recursion}

\section{Introduction}

\section{Recursive Mathematics}

\subsection{Fibonacci}
As it turns out, while this technically works...it's pretty terrible.  In short, using recursion, I managed to accidentally\footnote{All right, I did this totally on purpose.} write an $ O(2^n) $, or exponential time,  algorithm.  This is very bad.  This means increasing $ n $ by one \emph{doubles} the runtime of out algorithm!

This is because to solving the current 


\section{Printing Recursively}
Some of the upcoming examples  of the things we are about to see should not be actually  used and serve only as examples, like our \texttt{printThis} function.


\section{Recursive Linear Search}


\begin{minted}{Python3}
def search(theList, target):
	return search(theList, target, 0)


def search(theList, target, index):
	if theList[item] == target:
		return True
	
	
\end{minted}




\section{Binary Search}



\subsection{Runtime Analysis}




\subsubsection{How to not be scared of logarithms }
You may have learned that logarithms are the inverse operation to exponentiation.
This is an utterly useless definition when programming.


A more way of thinking about logarithms is "how many times can I recursively split something?"
For example, $\log_b x$ asks "how many times can I recursively split my $x$ items into $b$ seperate piles?"

A more concrete example: $\log_2 16 = 4$, not because $2^4 = 16$, but because a pile of 16 items can be split in half into two piles of 8, each pile of 8 can be split in half into two piles of 4, the 4's can be split into 2's, the 2's into 1's --- four splits total:

<picture>


In algorithm analysis, $log n$ in the time complexity is used to indicate that the search space gets split in half.
In the Binary Search algorithm above, we split the our search space in half each step of the way.  We start out looking at the middle item and then decide to look at all the items below or all the items above.  This reduces the number of items to search among from $n$ to $\frac{n}{2}$.  From there we perform the same choices and reduce that $\frac{n}{2}$ to $\frac{n}{4}$, then from  $\frac{n}{4}$ to  $\frac{n}{8}$ and so on.

\subsubsection{Back to it.}

\section{Recursive Backtracking}
Recursion really comes in handy when we are trying to solve complex puzzles.
One of the most famous examples of this is using

\subsection*{The Recursive Backtracking Algorithm}

\begin{minted}{C}
boolean solve(board,  pos){
	
	if( pos is such that there is nothing left to solve){
		return true;
	}
	
	for each possible choice {
		if(valid(choice)){
			mark board at pos with choice;
			if(solve(board, pos + 1) == true){
				return true;
			}
			unmark board at pos if needed, as choice was invalid
		}
	}
	clear any choices entered at pos on board, if needed;
	
	return false; // backtrack
}
	
	
\end{minted}


\subsection{Mazes Again}



\subsection{The Eight Queens Puzzle}

\chessboard[setwhite={Qa1,Qb7,Qc4,Qd6,Qe8,Qf2,Qg5,Qh3},showmover=false]

\subsubsection{Brute Force Solution}
A brute force algorithm means we will be checking every single possible state to find a solution.
In this case, a brute force solution for the Eight Queens Puzzle would every possible placement of eight queens on a chessboard, such as  these two:

<Chess notation here>

There are a total of $\binom{64}{8} = 4426165368$
possible ways to place 8 queens on a chessboard with 64 spaces.

\subsubsection{Recursive Solution Outline}
\begin{minted}{Java}
public static boolean solve(int[][] board, int col){
	
	if( col == 8){
		return true;
	}
	
	for(int row = 0; row < 8;row++){
		if(valid(choice)){
			mark board at pos with choice;
			if(solve(board, pos + 1) == true){
				return true;
			}
			unmark board at pos if needed, as choice was invalid
		}
	}
	clear any choices entered at pos on board, if needed;
	
	return false; // backtrack
}

\end{minted}

\subsubsection{A Place Holder For Validity}

\subsubsection{Performing the Recursion}

\subsubsection{Checking just One condition}


\subsubsection{Checking all the Conditions}




\subsection{Additional Problems left to the Reader}

\subsubsection{Knight's Tour}

\subsubsection{Sudoku}




\section{Recursive Combinations}



\section{Recursion and Puzzles}



\section{Recursion and Art}

\section{Recursion and Nature}
