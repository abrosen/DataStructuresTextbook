\documentclass[10pt,a4paper]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[cache=false]{minted}
\usemintedstyle{colorful}
%\definecolor{bg}{HTML}{282828} % from https://github.com/kevinsawicki/monokai
%\setminted{bgcolor=bg,breaklines=true}
\setminted{breaklines=true}
\begin{document}
\title{Data Structures}
\author{Andrew Rosen}
\date{}
\maketitle
\tableofcontents

\part{Preliminaries}

\chapter{Introduction}

\section{What is a Data Structures Course}
Data Structures is all about defining the different ways we can organize data.


\section{Why This Book?}

This text


\subsection{Where Does This Book Fit Into a Computer Science Curriculum }

Education in Computer Science is based around three core topics: translating the steps of solving a problem into a language a computer can understand, organizing data for solving problems, and techniques that can be used to solve problems. % reword
These courses typically covered in a university's introductory course, data structures course, and algorithms course respectively, although different universities decide exactly what content fits in which course.
Of course, there is are lot more concepts in computer science, from operating systems and low level programming,  to networks and how computers talk to each other. However, all these concepts rely on the knowledge gained in the core courses of programming, data structures, and algorithms.

 

This textbook is all about Data Structures, the middle section between learning how to program and the more advanced problem solving concepts we learn in Computer Science. 
Here, we focus on mastering the different ways to organize data, recognize the internal and performative differences between each structure, and learn to recognize the best (if there is one) for a given situation.


\subsection{What Are My Base Assumptions about the Reader?}

This textbook assumes that the student has taken a programming course that has covered the basics.
Namely: data types such as ints, doubles, booleans, and strings; if statements, for and while loops; and object orient programming.
This book is also suitable for the self taught programmer who has not learned much theoretical programming

\section{To The Instructor}

You'll note that this textbook lacks many of the 



Does the lack of varied exercises make cheating on assignments easier as semesters go on?  Yes, but that bridge was burned long ago.  
The cheating student can plagarize from various websites or anonymously hire another to do their work for them.
However, the student who cheats isn't exactly clever and certainly hasn't been exposed to much game theory.  
They will often cheat from the same source.  




\section{To The Student}


%\section{Science and Art}


\chapter{Functions and How They Work}

This will be an extremely short chapter, but an important one.

\section{The Runtime Stack}


\section{Passing Arguments}

\subsection{How it Works in Java}

\subsection{How it works in Python}


\chapter{The Array}

\section{Why Arrays}

\begin{itemize}
	\item because new language: 
	Since this is a data structures course, I assumed that students have had exposure to arrays or array like objects.
	This chapter goes into a bit of a deeper detail that may have been glossed over and Introduces the topic in the appropriate language if need be.
	
	In other words, I assume you know what an array is , but not necessarily how to use it in Java or Python\footnote{Although we use lists in python}.
	\item  because internal memory lookup
	\item Because we need to make sure internal knowledge is cohesive (eg arrays of objects are arrays of pointers/references)
\end{itemize}







\section{Java and Arrays}
The Array is a built in class in Java, but the syntax is a bit unique \footnote{Enough so that I constantly had to look up how to do it my first two years of undergraduate studies, so don't feel too bad if you have to do the same}

To create an array in Java we do:

\begin{minted}{Java}
Type[] myArray = new Type[sizeOfArray]
\end{minted}


Here, every item in the array is of whatever \texttt{Type} we want, which could be a Class or primitive.   
Arrays can be whatever integer size we desire, but once set it cannot be changed.
This is because to create an array, the computer allocates a contiguous block of memory.
If we wanted to resize it, there is no guarantee that this chunk of memory won't have things directly before or after it, preventing us from safely extending its range.

\section{Python and Arrays}
Python doesn't really do arrays.
It instead uses Lists, as we'll see in Cahpter \ref{chap-arraylist}.
\texttt{myNotArray\footnote{On styles:  Java convention is to use camel case for variable types (\texttt{myVariableName}), while python convention is to use underscores (\texttt{my\_variable\_name}).  I will be using the Java style camel-casing for variables throughout the book for consistency and because it is my preference.} = []} does not actually make an array like you assume it would in some other language.  Instead it makes A list (specifically an arraylist ) to contain these items.
This works exactly like an array in other languages, but you get some nifty operations that allow us to dynamically resize this array if we need it bigger or smaller.\footnote{We cover the specifics in Chapter \ref{arraylist}}



However, if you really want or need to use an array in python, you can.
There are two ways to accomplish this.The first way is the built in \texttt{array} package.    The python package \texttt{numpy} contains

Why would we want to use a 


\subsection{Cool Ways to Build an Array in Python}







\section{How an Array Works}


\subsection{Operations}

\subsubsection{Retrieving a item stored at an index}

\subsubsection{Setting the value of an index}

\subsection{Array Internals and the Memory Formula}

\section{Common Array Algorithms}

\subsection{Finding Values in an Array}
\subsubsection{Finding the Minimum}

\subsubsection{Finding the Average}


\subsection{Limitations}
Most frequent characters
Resizing



\chapter{Analyzing Algorithms}

\subsection{Cost}
Every function, operation, algorithm, or what have you that a computer performs has a \emph{cost}. In fact, there are always multiples costs;  we often just focus on the most important one or two costs.  
What is most important depends on context.

However, when we measure cost, we need to do abstractly.  
When we measure the amount of time that an algorithm takes

\subsubsection{Time}
A time cost is a measure of not just how long it takes a program to finish executing, bit also how the length of execution is affected by adding additional item.

Time is almost always \emph{the most important cost}.

\subsubsection{Space}
\subsubsection{Energy}
\subsubsection{Other costs - Bandwidth}

\section{Big O Notation}

\begin{itemize}
	\item What is big O
	
	\item  how to read it
	\item Aside about big omega and theta
	\item How wrong usage annoys mathematician
	\item refers to cost in general, but used for time usually
	\item  space complexity 
	\item Common runtimes
	\item runtimes we''ll focus on now
	\item runtimes we focus on later
\end{itemize}



\subsection{Space Complexity}

\section{Examples with Arrays}

\begin{itemize}
	
	\item Retrieval  - refer back to earlier chapter for address lookup 
	\item Replacement
	\item Linear Search
	\item Binary Search
\end{itemize}



\subsection{Selection Sort}



\subsection{Bubble Sort}
\subsection{Insertion Sort}
\subsection{Other Sorting Algorithms}


\section{The Formal Mathematics of Big O Notation}
\section{Other Notations}


\section{When To Ignore Costs}


\part{Lists}
\label{part-list}
\include{arraylists}
\include{linkedlists}
\include{stacks}
\include{queues}

\part{Recursion}
\include{recursion}

\chapter{Trees}


Our next major data structure is trees.  Specifically, we will be looking at binary search trees.

Trees are an excellent data structure for storing things since they implement all the operations we care about for collections in logarhythmic time\footnote{Specifically , Trees implement everything in average case log rhythmic time and worst case linear time , but if we do a bit of extra work and make it a self balancing binary tree (which will seem much later in this chapter) we can make this tree worst case log arhythmic for all operations}


However, trees are not without limitations.  Trees will only work with data that can be stored hierarchically or in an order.

\section{The Parts of a Tree}

The first thing we need to do when introducing trees is define a vocabulary.  

Much like the linked list, a tree is made of nodes.
However, unlike a linked list , nodes in a tree are not arranged in a line,
Instead, they are arranged in a heirachy.

Each node sit above multiple other nodes , with the nodes below it being referred to as their children or child nodes.  The node connecting all these children is called the parent.

<A picture of one node, Represented by a circle with four arrows coming out below it. Each arrow points to yet another node.  The Node with the arrows coming out of it is the parent, and the nodes below it are the children >


This relationship can be extended Ad infinitum as we can see with the picture below 


<Picture with nodes labeled>


However anything above grandchild and grandparent just becomes tedious , so we tend to  Generalize this relationship to ancestors and descendants.  A key point here is to remember that while we are borrowing terms from the family tree , nodes will only have one parent . Each node can have multiple children, however .


We refer to the links connect each of the nodes as branches or links or edges.  This tends to be a matter of personal preference.



Finally , we have one special node that sits above all the other nodes . This note is the root and it is analogous to the head of a linked list . All of our operations will start at the root of the node\footnote{Remember , programmers are stereotypically outdoors of averse, So they May have forgotten what a real tree looks like.  Thus, we'll see that the root of the tree is at the top of the tree and our leaves are at the bottom\footnote{Or maybe it's some weird hydroponic zero-G kind of thing.}}.


Remember , programmers are stereotypically outdoors of averse, So they May have forgotten what a real tree looks like.  Thus, we'll see that the root of the tree is at the top of the tree and our leaves are at the bottom\footnote{Or maybe it's some weird hydroponic zero-G kind of thing.}


\subsection{Where the  Recursion comes in}
There is a reason we learned recursion before we introduce trees. Trees are the exemplar recursive data structure

Each tree has a root and That route has children .  If we view each of those children as the root of their own subtree , this can make our algorithms for adding removing and searching extremely easy to write.

<picture Of tree, the recursive subtrees are dash circled.>

<Picture of the left subtree, with it's trees circled>




















\section{Binary Search Trees}

A diagram of a binary search tree.  It is made up of nodes, represented by circles, and edges (also called links or branches), represented by arrows.  


\footnote{An aside about array based implementations.}

\section{Building a Binary Search Tree}

\subsection{The Code Outline}


We use the \texttt{Comparable} class in Java to require that all objects stored in the tree has a \textbf{total ordering}\footnote{The formal definition is as follows}.%TODO Formal defininition in the footnote
In practice, this means that anything \texttt{Comparable} can be sorted.

Python, of course, doesn't need these restrictions.
\begin{minted}{Java}
public class BinaryTree<E extends Comparable<E>> {
}
\end{minted}




Much like our Linked List, we don't need much in the way of instance variables.  We'll create a \texttt{root} to keep track of the starting place for our tree and size to keep track of how many items we have stored.

Finally, we will also create our inner \texttt{Node} class for the Tree.
It needs to hold the item and the locations of the left and right children.
We'll also go ahead and add a The constructor and a method for printing out the item in the node (\texttt{toString} in Java and \texttt{\_\_str\_\_} in Python )

\begin{minted}{Java}
public class BinaryTree<E extends Comparable<E>> {
	private Node<E> root;
	private int size;
	
	public BinaryTree() {
		this.root = null;
		
	}

	/* Other code will go here.*/

	private static class Node<E extends Comparable<E>> {
		private E item;
		private Node<E> left;  // left child
		private Node<E> right; // right child
		public Node(E item) {
			this.item = item;
		}
		public String toString() {
			return item.toString();
		}
	}

	
}
\end{minted}


\subsection{Add}




\subsection{Contains}

\subsection{Delete}


\chapter{Heaps}


\section{Priority Queues}

\section{Removing From other locations}

\chapter{Sorting}


\section{Quadratic-Time Algorithms}

\subsection{Bubble Sort}

\subsection{Selection Sort}

\subsection{Insertion Sort}


\section{Log-Linear Sorting Algorithms}
The most commonly used sorting algorithms take $ O(n \lg(n)) $ time.
This is the hard limit on runtime %TODO Cite or correct
\subsection{Tree Sort}
The tree sort is the simplest algorithm to we will cover. Performing Tree sort is a matter of three simple steps

\begin{enumerate}
	\item Create a tree.
	\item Load the items you want to sort into the tree.
	\item Perform an inorder traversal of the tree.
\end{enumerate}


The performance of this algorithm depends completely on the type of tree we create for this algorithm.  Using a self-balancing binary search tree, adding $ n $ items to the tree takes $ O(n\lg(n)) $ and an in order traversal takes $ O(n) $ steps, for a grand total of $ O(n) $ runtime.  Using a binary search tree that does not self balance means that there is a worst case scenario of $ O(n^{2}) $ for adding all the $ n $ items.

Using a tree also means we use extra space since all the data has to be moved into a tree, using $ O(n) $ space.
\subsection{Heap Sort}
You might expect that heapsort deserves the same treatment as treesort.
After all, a heap has the same structure as a tree and both are constructed to perform operations in $log n $ time.

\subsection{Heapify}

\subsection{Quick Sort}
\subsection{Merge Sort}



\section{Unique Sorting Algorithms}


\subsection{Shell Sort}

\subsection{Radix Sort}

\section{State of the Art Sorting Algorithms}

\subsection{Tim Sort}
\subsection{Quick Sort}
\section{But What if We Add More Computers: Parallelization and Distributed Algorithms}



\subsubsection{Parallel VS Distributed}

\subsubsection{Map Reduce }


\section{Further Reading}

\part{Hashing}

\chapter{Sets}
\label{chap-sets}
Sets are the like mathematical sets


\chapter{Maps}
\chapter{Hash Tables}
\subsection{Creating a Hash Function}



\chapter{Map Reduce}


\section{Map}
The \texttt{map()} operation\footnote{It is mildly confusing that there is a \texttt{map} data structure and a \texttt{map()} operation, so I will be marking the \texttt{map()} operation with a function invocation.} is a powerful function that may require us to think  differently about the way we have approached programming so far.

The map operation takes in 2 arguments, a collection and a function to apply to every item in the collection




When we are writing functions , we are creating new verbs for our programming language to use . These verbs take in arguments, nouns that we may have declared or defined ourselves. But one thing that we May not have done yet is passing a function as an argument to another function.

This is not an uncommon operation in mathematics Example listed below 



The semantics of this in every programming language is different , but the concept is the same 



Why introduces here? Because a lot of common operations that can be done with map reduce involve using hash tables 


\part{Relationships}

\chapter{Graphs}

In some ways, Graphs are the most important data structure.  
Graphs represent and model relationships, and humans are defined by relationships.
The archetypical examples of graphs used to be maps and the distances between landmarks or looking for the shortest path.

With the advent of social media, we can talk about graphs with a few examples that might be easier to intuit.

\section{Introduction and History}


\section{Qualities of a Graph}

The physical layout of a graph doesn't actually matter\footnote{Some properies, such as whether a graph is \emph{planar} or \emph{bipartite} effectively care if a graph can be physically laid out in a certain way.}

\subsection{Vertices}

\begin{itemize}
	\item Vertices must be unique.
\end{itemize}

\subsection{Edges}

\subsubsection{Undirected Edges}

\subsubsection{Directed Edges}

\subsubsection{Weighted Edges}


\section{Special Graphs and Graph Properties}

\subsection{Planar Graphs}
Graphs that are planar can have their vertices and edges laid out in such a way that no two edges will cross.



\subsection{Bipartite Graphs}

\subsection{Directed Acyclic Graphs}


\section{Building a Graph}

\subsection{Adjacency List}
\subsection{Adjacency Matrix}

\section{Graph Libraries}

\subsection{Java - JUNG}

\subsection{Python - networkx}

There is only one realistic choiceforusing graphs in Python.  The package networkx is extremely powerful, extremely versatile,and actively maintained.



\chapter{Graph Algorithms}

\section{Searching and Traversing}

\subsection{Breadth First Search}

\subsection{Depth First Search}




\section{Shortest Path}

\subsection{Djikstra's Algorthim}

\subsubsection{Improving The Algorithm}

\subsubsection{Failure Cases}


\subsection{Bellman-Ford}



\section{Topological Sorting}

\subsection{Khan's Algorithm}

\section{Minimum Spanning Trees}


\subsection{Kruskal's Algorithm}
\subsection{Prim's Algorithm }



\section{Graphs, Humans, and Networks}

\subsection{The Small World}
\subsubsection{The Milgram Experiment}
%In 1960, the fugative Nazi war criminal Adolf Eichmann was captured by 
\subsubsection{The Less-Known Milgram Experiment}

\subsection{Scale Free Graphs}


\section{Graphs in Art and Nature - Voronoi Tessellation}

\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{pics/dragonfly_wing_joi_ito}
	\caption{The wings of a dragonfly. Credit: Joi Ito (CC BY 2.0)}
	\label{fig:dragonflywingjoiito}
\end{figure}



\part{Beyond}

\chapter{A Nontechnical Introduction to NP-Completeness}

\section{The Traveling Salesperson Problem (TSP)}
\section{The Longest Path Problem}
\section{The Rudrata/Hamiltonian Path Problem}
\chapter{Other Data Structures}


\section{Skip Lists}


\chapter{Distributed Hash Tables}



\end{document}